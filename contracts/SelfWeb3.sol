//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';

import "./SelfValidator.sol";

// @title The Selfweb3 contract is used to provide decentralized key management services.
// @author refitor
contract SelfWeb3 is Ownable {
    using SafeMath for uint256;
    using Address for address payable;
    struct MetaData {
        address Web2Address;
        uint256 RegistTotal;
        uint256 feeRate;
    }
    struct SelfData {
        address Wallet;         // The wallet bound by the user is used to interact with the web3 contract
        bytes RecoverID;        // Used for social recovery of web3 account.
        bytes SelfKey;          // Self core keys, for decrypting Webauthn ciphertext information.
        bytes SelfPrivate;      // Self private key, participate in dynamic computing sharing key.
        bytes32 VerifyRoot;     // The root of merkleTree for on-chain associated validation.
    }
    MetaData private _metaData;
    mapping (address => SelfData) private _dataMap;
    mapping (address => uint256) private _vaultMap;

    /**
     * @dev constructor is used to populate the meta information of the contract.
     * @param web2Address The web2 server address.
     * @param feeRate fee deduction percentage set by the contract creator, demo: 500 / 10000, feeRate is 500.
     */
    constructor(address web2Address, uint256 feeRate) Ownable(msg.sender) {
        _metaData = MetaData(web2Address, 0, feeRate);
    }

    /**
     * @dev Meta is used to load the meta information of the contract.
     */
    function Meta() view public returns (uint256 registTotal, uint256 feeRate) {
        MetaData memory md = _get();
        return (md.RegistTotal, md.feeRate);
    }

    /**
     * @dev Registered is used to check if the user is registered.
     * @param selfAddress The user’s unique address in selfWeb3.
     */
    function Registered(address selfAddress) view external returns (bool registered) {
        SelfData memory sd = _getKV(selfAddress);
        return sd.SelfPrivate.length != 0;
    }

    /**
     * @dev Register is used to register the web3 user.
     * @param selfAddress The user’s unique address in selfWeb3.
     * @param recoverID Used for social recovery of web3 account.
     * @param selfKey Self core keys, for decrypting Webauthn ciphertext information.
     * @param selfPrivate Self private key, participate in dynamic computing sharing key.
     */
    function Register(address selfAddress, bytes calldata recoverID, bytes calldata selfKey, bytes calldata selfPrivate) external payable {
        require(selfKey.length != 0, "SelfKey must be non-empty");
        require(recoverID.length != 0, "recoverID must be non-empty");
        require(selfPrivate.length != 0, "selfPrivate must be non-empty");
        SelfData memory sd = _getKV(selfAddress);
        require(sd.SelfPrivate.length == 0, "duplicate registration");
        sd = SelfData(msg.sender, recoverID, selfKey, selfPrivate, bytes32(0));
        _setKV(selfAddress, sd);
    }

    /**
     * @dev Load is used to load the key information.
     * @param selfAddress The user’s unique address in selfWeb3.
     * @param signature signature signed by the web3 user.
     * @param message random string dynamically generated by the front end.
     */
    function Load(address selfAddress, bytes calldata signature, bytes calldata message) view external returns (bytes memory recoverID, bytes memory selfKey, bytes memory selfPrivate) {
        SelfData memory sd = _getKV(selfAddress);
        require(sd.SelfPrivate.length != 0, "not registered yet");
        require(SelfValidator.WalletVerify(signature, message) == sd.Wallet, "permission denied");
        return (sd.RecoverID, sd.SelfKey, sd.SelfPrivate);
    }

    /**
     * @dev Rebind is used to rebind the wallet.
     * @param selfAddress The user’s unique address in selfWeb3.
     * @param wallet the old wallet address.
     * @param vparam Used for on-chain verification.
     */
    function Rebind(address selfAddress, address wallet, bytes calldata vparam) external payable {
        MetaData memory md = _get();
        SelfData memory sd = _getKV(selfAddress);
        address[] memory sigAddrList = new address[](2);
        sigAddrList[0] = selfAddress;
        sigAddrList[1] = md.Web2Address;
        bytes32 verifyRoot = SelfValidator.RelateVerify(sd.VerifyRoot, vparam, sigAddrList); // Prioritize verification
        sd = SelfData(msg.sender, sd.RecoverID, sd.SelfKey, sd.SelfPrivate, verifyRoot);
        require(wallet == sd.Wallet, "permission denied with invalid wallet");
        require(sd.SelfPrivate.length != 0, "not registered yet");
        _setKV(selfAddress, sd);
        delete sigAddrList;
    }

    /**
     * @dev Registered is used to check if the user is registered.
     * @param selfAddress The user’s unique address in selfWeb3.
     */
    function Balance(address selfAddress) view external returns (uint256 amount) {
        SelfData memory sd = _getKV(selfAddress);
        require(sd.SelfPrivate.length != 0, "not registered yet");
        return _getVault(selfAddress);
    }

    /**
     * @dev Deposit is used to deposit native assets supported by selfWeb3.
     * @param selfAddress The user’s unique address in selfWeb3.
     * @param vparam Used for on-chain verification.
     */
    function Deposit(address selfAddress, bytes memory vparam) external payable {
        MetaData memory md = _get();
        SelfData memory sd = _getKV(selfAddress);

        // on-chain associated validation
        address[] memory sigAddrList = new address[](2);
        sigAddrList[0] = selfAddress;
        sigAddrList[1] = md.Web2Address;
        bytes32 verifyRoot = SelfValidator.RelateVerify(sd.VerifyRoot, vparam, sigAddrList); // Prioritize verification
        if(verifyRoot != sd.VerifyRoot && verifyRoot != bytes32(0)) {
            sd.VerifyRoot = verifyRoot;
            _setKV(selfAddress, sd);
        }
        delete sigAddrList;

        require(msg.value > 0, "invalid deposited amount");
        require(sd.SelfPrivate.length != 0, "not registered yet");

        // on-chain vault management
        _setVault(selfAddress, _getVault(selfAddress) + msg.value);
    }

    /**
     * @dev Withdraw is used to withdraw native assets supported by selfWeb3.
     * @param selfAddress The user’s unique address in selfWeb3.
     * @param vparam Used for on-chain verification.
     * @param amount withdrawal native assets amount.
     */
    function Withdraw(address selfAddress, bytes memory vparam, uint256 amount) external payable {
        MetaData memory md = _get();
        SelfData memory sd = _getKV(selfAddress);

        // on-chain associated validation
         address[] memory sigAddrList = new address[](2);
        sigAddrList[0] = selfAddress;
        sigAddrList[1] = md.Web2Address;
        bytes32 verifyRoot = SelfValidator.RelateVerify(sd.VerifyRoot, vparam, sigAddrList); // Prioritize verification
        if(verifyRoot != sd.VerifyRoot && verifyRoot != bytes32(0)) {
            sd.VerifyRoot = verifyRoot;
            _setKV(selfAddress, sd);
        }
        delete sigAddrList;

        require(amount > 0, "invalid withdraw amount");
        require(sd.SelfPrivate.length != 0, "not registered yet");

        // on-chain vault management
        if (md.feeRate > 0) {
            uint256 payFee = amount * md.feeRate / 10000;
            require(amount - payFee > 0 && amount - payFee <= _getVault(selfAddress), "not enough extractable quantity");
            payable(owner()).sendValue(payFee);
            amount = amount - payFee;
        } else {
            require(amount > 0 && amount <= _getVault(selfAddress), "not enough extractable quantity");
        }
        _setVault(selfAddress, _getVault(selfAddress) - amount);
    }

    /**
     * @dev _setKV is used to set dataMap.
     * @param k the key for _datamap.
     * @param v the value for _datamap.
     */
    function _setVault(address k, uint256 v) private {
        _vaultMap[k] = v;
    }

    /**
     * @dev _getKV is used to get the value by the key.
     * @param k the key for _datamap.
     */
    function _getVault(address k) private view returns (uint256) {
        return _vaultMap[k];
    }


    /**
     * @dev _setKV is used to set dataMap.
     * @param k the key for _datamap.
     * @param v the value for _datamap.
     */
    function _setKV(address k, SelfData memory v) internal {
        _dataMap[k] = v;
        _metaData.RegistTotal = _metaData.RegistTotal + 1;
    }

    /**
     * @dev _getKV is used to get the value by the key.
     * @param k the key for _datamap.
     */
    function _getKV(address k) view internal returns (SelfData memory sd) {
        return _dataMap[k];
    }

    /**
     * @dev _get is used to load the meta information of the contract.
     */
    function _get() view internal returns (MetaData memory md) {
        return _metaData;
    }
}